// copilot-runner is a binary that executes Copilot SDK sessions based on JSON configuration.
//
// It reads a JSON config file that specifies all parameters for the session
// (model, tools, MCP servers, prompt, etc.) and uses the Copilot SDK to
// programmatically control the execution. The binary produces structured
// JSON output with metrics and conversation data.
//
// Usage:
//
//	copilot-runner --config /path/to/config.json [--model-override MODEL] [--version]
//
// The config file is generated by the gh-aw compiler as part of the
// CopilotSDKEngine's GetExecutionSteps output.

package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/exec"
)

var version = "dev"

func main() {
	configPath := flag.String("config", "", "Path to JSON config file (required)")
	modelOverride := flag.String("model-override", "", "Override the model from config")
	showVersion := flag.Bool("version", false, "Print version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("copilot-runner version %s\n", version)
		os.Exit(0)
	}

	if *configPath == "" {
		fmt.Fprintf(os.Stderr, "Error: --config flag is required\n")
		fmt.Fprintf(os.Stderr, "Usage: copilot-runner --config /path/to/config.json\n")
		os.Exit(1)
	}

	// Load configuration
	config, err := LoadConfig(*configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
		os.Exit(1)
	}

	// Apply model override if specified
	if *modelOverride != "" {
		config.Model = *modelOverride
	}

	// Create and run the runner
	runner := NewRunner(config)
	ctx := context.Background()

	output, err := runner.Run(ctx)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)

		// Write error output
		if writeErr := WriteOutput(output, config.LogDir); writeErr != nil {
			fmt.Fprintf(os.Stderr, "Failed to write output: %v\n", writeErr)
		}
		os.Exit(1)
	}

	// Write successful output
	if err := WriteOutput(output, config.LogDir); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: failed to write output: %v\n", err)
	}

	fmt.Fprintf(os.Stderr, "[copilot-runner] Session completed successfully\n")
}

// commandWrapper wraps exec.Cmd to allow testing
type commandWrapper struct {
	cmd *exec.Cmd
}

func newCommand(ctx context.Context, name string, args ...string) *commandWrapper {
	return &commandWrapper{cmd: exec.CommandContext(ctx, name, args...)}
}

func (c *commandWrapper) setStdout(w *os.File) {
	c.cmd.Stdout = w
}

func (c *commandWrapper) setStderr(w *os.File) {
	c.cmd.Stderr = w
}

func (c *commandWrapper) setDir(dir string) {
	c.cmd.Dir = dir
}

func (c *commandWrapper) run() error {
	return c.cmd.Run()
}
